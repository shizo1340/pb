---
import Base from './Base.astro';
import TOC from '../components/TOC.astro';
import Breadcrumbs from '../components/Breadcrumbs.astro';
import EeatBox from '../components/EeatBox.astro';
import site from '../data/site.json';
import nav from '../data/nav.json';
import kvCardsUrl from '../scripts/anbieter-kv-cards.js?url';
import { makeBreadcrumbs } from '../lib/breadcrumbs';
import { breadcrumbJsonLd, pageJsonLd } from '../lib/schema';

const fm = Astro.props.frontmatter ?? Astro.props;

const format = fm.format ?? fm.type ?? 'guide';
const schemaType =
  format === 'home' ? 'WebPage'
  : (format === 'hub' || format === 'directory') ? 'CollectionPage'
  : 'Article';

const pageUrl = (fm.canonical ?? (fm.url ? (site.baseUrl.replace(/\/$/, '') + fm.url) : Astro.url?.href)) || Astro.url?.href;

const {
  title = site.siteName,
  description = site.defaultDescription,
  robots = 'index,follow',
  readingTime = true,
  updated = null,
  chapter = null,
  level = null,
  ogImage = site.defaultOgImage,
  canonical = null,
  url = null,
  // Optional: call-to-action buttons in the hero.
  // Example frontmatter:
  // ctaPrimary: { label: "Plan erstellen", href: "/start/empfehlungen-nach-level/" }
  // ctaSecondary: { label: "Sofortmaßnahmen", href: "/start/quick-wins/" }
  ctaPrimary = null,
  ctaSecondary = null,

  // Optional metadata for reproducibility / freshness
  tested_with = null,
  changelog = null,

  // Optional extra JSON-LD records (e.g. ItemList for directories)
  structuredDataExtra = null,
} = fm;

// Provider summary (only for /anbieter/* pages)
const provider = fm.provider ?? null;

const pick = (v) => (v === null || v === undefined) ? '' : String(v).trim();
const short = (s, max = 44) => {
  const t = pick(s);
  if (!t) return '';
  return t.length > max ? `${t.slice(0, max - 1)}…` : t;
};

const pricingLabel = (p) => {
  const x = pick(p).toLowerCase();
  if (!x) return '';
  if (x === 'free' || x === 'kostenlos') return 'Kostenlos';
  if (x === 'freemium') return 'Freemium';
  if (x === 'paid' || x === 'subscription' || x === 'one-time') return 'Kostenpflichtig';
  if (x === 'mixed' || x === 'gemischt') return 'Gemischt';
  if (x === 'unknown' || x === 'unbekannt') return 'Unbekannt';
  return pick(p);
};

const ossLabel = (v) => {
  const x = pick(v).toLowerCase();
  if (!x) return '';
  // Neutral wording (facts, not a rating)
  if (x === 'yes' || x === 'true') return 'offen';
  if (x === 'partial') return 'teilweise offen';
  if (x === 'no' || x === 'false') return 'nicht offen';
  return pick(v);
};

const kontoValue = (v) => {
  const raw = pick(v);
  const x = raw.toLowerCase();
  if (!raw) return '';
  const hasNo = x.includes('no');
  const hasYes = x.includes('yes');
  if (hasNo && hasYes) return 'optional';
  if (hasNo && !hasYes) return 'nicht erforderlich';
  if (hasYes && !hasNo) return 'erforderlich';
  if (x.includes('optional')) return 'optional';
  return short(raw, 40);
};

const selfHostLabel = (v) => {
  const x = pick(v).toLowerCase();
  if (!x) return '';
  if (x === 'yes' || x === 'true') return 'Self-Hosting: Ja';
  if (x === 'no' || x === 'false') return 'Self-Hosting: Nein';
  return `Self-Hosting: ${pick(v)}`;
};

const regionShort = (v) => {
  const raw = pick(v);
  if (!raw) return '';
  // keep first clause, strip parentheses, keep it short
  const cleaned = raw
    .replace(/\([^)]*\)/g, '')
    .split(';')[0]
    .split(',')[0]
    .trim();
  return short(cleaned, 26);
};

const firstClause = (v) => {
  const raw = pick(v);
  if (!raw) return '';
  return short(raw.split(';')[0].split('—')[0].trim(), 34);
};

const regionLabel = (v) => {
  const raw = pick(v);
  const x = raw.toLowerCase();
  if (!raw) return '';
  return (
    {
      eu: 'EU/EWR',
      ch: 'Schweiz',
      uk: 'UK',
      us: 'USA',
      ca: 'Kanada',
      other: 'Andere',
      unknown: 'Unklar',
    }[x] || raw
  );
};

const logsLabel = (v) => {
  const raw = pick(v);
  const x = raw.toLowerCase();
  if (!raw) return '';
  return (
    {
      none: 'keine',
      minimal: 'minimal',
      some: 'vorhanden',
      configurable: 'konfigurierbar',
      unknown: 'unklar',
    }[x] || raw
  );
};

const retentionLabel = (v) => {
  const raw = pick(v);
  const x = raw.toLowerCase();
  if (!raw) return '';
  return (
    {
      short: '≤7 Tage',
      mid: '≤30 Tage',
      long: '≤365 Tage',
      verylong: '>365 Tage',
      configurable: 'konfigurierbar',
      specified: 'angegeben',
      unknown: 'unklar',
    }[x] || raw
  );
};


const providerBadges = (() => {
  if (!provider) return [];
  const out = [];
  const cat = pick(provider.category);
  if (cat) out.push({ label: `Kategorie: ${cat}`, tone: 'muted' });
  const konto = kontoValue(provider.account_required);
  if (konto) out.push({ label: `Konto: ${konto}`, tone: 'muted' });
  const oss = ossLabel(provider.open_source);
  // Badges should be descriptive, not a score → keep neutral tone
  if (oss) out.push({ label: `Quellcode: ${oss}`, tone: 'muted' });
  const selfh = selfHostLabel(provider.self_host_possible);
  if (selfh) out.push({ label: selfh, tone: 'muted' });
  return out;
})();

const providerTiles = (() => {
  if (!provider) return [];
  const tiles = [];
  // Big tiles should focus on the most scan-friendly facts (no duplicates with badges)
  // Suggested by user: Region, Logs, Retention, Preis
  const price = pricingLabel(provider.pricing) || 'Nicht angegeben';
  tiles.push({ k: 'Preis', v: price });

  const reg =
    (provider.region && pick(provider.region).toLowerCase() !== 'unknown'
      ? regionLabel(provider.region)
      : regionShort(provider.jurisdiction)) || 'Nicht angegeben';
  tiles.push({ k: 'Region', v: reg });

  const logsBase = logsLabel(provider.logs) || 'Nicht angegeben';
  const logsNote = firstClause(provider.logs_notes);
  const logs = logsNote ? `${logsBase} — ${logsNote}` : logsBase;
  tiles.push({ k: 'Logs', v: logs });

  const retBase = retentionLabel(provider.retention) || 'Nicht angegeben';
  const retNote = firstClause(provider.retention_notes);
  const ret = retNote ? `${retBase} — ${retNote}` : retBase;
  tiles.push({ k: 'Retention', v: ret });

  return tiles;
})();

const providerLinks = (() => {
  if (!provider) return [];
  const links = [];
  const w = pick(provider.website);
  // Outgoing (monetizable) clicks should go through /go/<slug>/ so affiliate logic
  // can be centralized without touching editorial pages.
  const path = String(Astro.url?.pathname || '');
  const providerSlug = path.toLowerCase().startsWith('/anbieter/')
    ? path.replace(/^\/anbieter\//i, '').replace(/\/$/, '').trim()
    : '';
  if (w) links.push({ label: 'Website', href: providerSlug ? `/go/${providerSlug}/` : w });
  const pol = provider.policies ?? {};
  if (pol.privacy && pol.privacy !== 'Nicht angegeben') links.push({ label: 'Privacy Policy', href: pol.privacy });
  if (pol.terms && pol.terms !== 'Nicht angegeben') links.push({ label: 'AGB/Terms', href: pol.terms });
  if (pol.transparency && pol.transparency !== 'Nicht angegeben') links.push({ label: 'Transparency', href: pol.transparency });
  if (pol.warrant_canary && pol.warrant_canary !== 'Nicht angegeben') links.push({ label: 'Warrant Canary', href: pol.warrant_canary });
  return links.slice(0, 5);
})();

const shortFirst = (v) => {
  const t = pick(v);
  if (!t) return '';
  const first = t.split(';')[0].split('—')[0].split('(')[0].trim();
  return short(first, 42);
};

// Draft safety: if a page has a status and it's not 'done', don't index it and don't render draft body.
const statusRaw = fm.status ?? fm.provider?.status ?? null;
const status = String(statusRaw || '').trim().toLowerCase();
const isDone = !status || status === 'done';
// Allow explicit per-page noindex (useful for thin/placeholder pages).
// If set, we also add nofollow to avoid leaking crawl signals to sponsored destinations.
const explicitNoindex = (fm.noindex === true) || (String(fm.robots || '').includes('noindex'));
const robotsFinal = isDone
  ? (explicitNoindex ? 'noindex,nofollow' : robots)
  : 'noindex,follow';

// /anbieter/* is excluded from template cleanups.
const isAnbieter = String(Astro.url?.pathname || '').toLowerCase().startsWith('/anbieter');
// Avoid showing the global default description in the hero on most pages (it feels generic).
// Keep the meta description as-is; only hide the visible subline.
const heroSub = (description && (isAnbieter || description !== site.defaultDescription)) ? description : null;

// headings come from the Markdown compiler, not from frontmatter
const headings = Astro.props.headings ?? fm.headings ?? [];

// Match TOC behaviour: only show when there are at least 2 H2 headings.
// If there is no TOC, the grid would otherwise place the article into the first (sidebar) column.
const h2Count = headings.filter((h) => h.depth === 2).length;
const showToc = isDone && (h2Count >= 2);

// --- Scan helper: build quick anchor links if common H2 sections exist
const slugOf = (re) => {
  const h = headings.find((x) => x.depth === 2 && re.test(String(x.text || x.heading || '')));
  return h?.slug ?? '';
};

const quickSlug = slugOf(/quick\s*wins/i);
const verifySlug = slugOf(/prüfen|pruefen|check/i);
const pitfallsSlug = slugOf(/stolpersteine|fehler|problem/i);

// Build anchor hrefs for the "In 20 Sekunden" jump box.
// These variables must always exist; otherwise Astro's SSR build will throw.
const quickHref = quickSlug ? `#${quickSlug}` : null;
const verifyHref = verifySlug ? `#${verifySlug}` : null;
const pitfallsHref = pitfallsSlug ? `#${pitfallsSlug}` : null;

const in20 = Boolean(quickHref || verifyHref || pitfallsHref);

// Render slot once so we can calculate reading time at build-time.
// For draft / archived pages we intentionally don't render the body to avoid leaking template text.
const slotHtml = isDone ? await Astro.slots.render('default') : '';

// Show the sticky Pfad A/B/C switcher only on pages that actually use the Pfad convention.
// We look for the markers in the rendered HTML (covers Markdown + embedded <details>/<summary>).
const hasPfade = isDone && /Pfad\s*[ABC]\b/i.test(slotHtml);

const showReadingTime = readingTime !== false;

let readingLabel = 'In Arbeit';
if (isDone && showReadingTime) {
  const plainText = slotHtml
    .replace(/<script[\s\S]*?<\/script>/g, ' ')
    .replace(/<style[\s\S]*?<\/style>/g, ' ')
    .replace(/<[^>]+>/g, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const words = plainText ? plainText.split(' ').length : 0;
  const readingMinutes = Math.max(1, Math.round(words / 200));
  readingLabel = `Lesezeit: ${readingMinutes} Min.`;
}

// Prev/Next within the current chapter (derived from nav.json order)
const norm = (p) => (p && p.endsWith('/') ? p : `${p}/`);
const currentPath = norm(Astro.url.pathname);
const seg = currentPath.split('/').filter(Boolean)[0] || '';
const chapterCol = (nav.chapters ?? []).find((col) => {
  const sample = col?.items?.[0]?.href ?? '';
  const s = sample.split('/').filter(Boolean)[0] || '';
  return s === seg;
});

// Prev/Next wird weiter unten anhand der Ordner-Ebene berechnet.

const depth = (p) => norm(p).split('/').filter(Boolean).length;
const parentPathOf = (p) => {
  const parts = norm(p).split('/').filter(Boolean);
  if (parts.length <= 1) return '/';
  return `/${parts.slice(0, -1).join('/')}/`;
};

const pageLabelByHref = new Map();
const allHrefs = [];

// Reihenfolge aus nav.json (falls eine Seite dort auftaucht)
const navOrder = new Map();
{
  let i = 0;
  for (const ch of (nav?.chapters || [])) {
    for (const it of (ch.items || [])) {
      const href = norm(it.href);
      if (!navOrder.has(href)) navOrder.set(href, i++);
      if (it.label) pageLabelByHref.set(href, it.label);
    }
  }
}

// Alle Seiten aus src/pages (md + astro) sammeln
const mods = import.meta.glob('../pages/**/*.{md,astro}', { eager: true });
for (const [file, mod] of Object.entries(mods)) {
  // URL: bevorzugt aus Frontmatter, sonst aus Dateipfad ableiten
  let href = '';
  if (mod && typeof mod === 'object' && mod.frontmatter && mod.frontmatter.url) {
    href = norm(mod.frontmatter.url);
  } else {
    // "../pages/a/b/index.astro" -> "/a/b/"
    const rel = file.replace('../pages', '').replace(/\\/g, '/');
    const cleaned = rel.replace(/\.(md|astro)$/, '');
    if (cleaned.endsWith('/index')) {
      href = norm(cleaned.slice(0, -('/index'.length)) + '/');
    } else {
      href = norm(cleaned + '/');
    }
  }
  if (!href.startsWith('/')) continue;
  if (!allHrefs.includes(href)) allHrefs.push(href);

  // Label: Frontmatter title, sonst aus URL
  const label = (mod && typeof mod === 'object' && mod.frontmatter && mod.frontmatter.title)
    ? String(mod.frontmatter.title).trim()
    : href.split('/').filter(Boolean).slice(-1)[0]?.replace(/-/g, ' ') || href;

  if (!pageLabelByHref.has(href)) pageLabelByHref.set(href, label);
}

const depthOf = (href) => norm(href).split('/').filter(Boolean).length;
const parentOf = (href) => {
  const h = norm(href);
  if (h === '/') return null;
  const parts = h.split('/').filter(Boolean);
  if (parts.length <= 1) return '/';
  return '/' + parts.slice(0, -1).join('/') + '/';
};

const byOrder = (a, b) => {
  const ia = navOrder.has(a) ? navOrder.get(a) : 1e9;
  const ib = navOrder.has(b) ? navOrder.get(b) : 1e9;
  if (ia !== ib) return ia - ib;
  const la = pageLabelByHref.get(a) || a;
  const lb = pageLabelByHref.get(b) || b;
  const c = String(la).localeCompare(String(lb), 'de');
  return c !== 0 ? c : a.localeCompare(b);
};

let prev = null;
let next = null;

const currentDepth = depthOf(currentPath);
const currentParent = parentOf(currentPath);

// Wenn du auf einem Ordner-Index bist, nimm als "Weiter" die erste direkte Unterseite
const directChildren = allHrefs
  .filter((h) => parentOf(h) === currentPath && depthOf(h) === currentDepth + 1)
  .sort(byOrder);

if (directChildren.length > 0) {
  // Ordner-Startseite: nur "Weiter" (erste Unterseite)
  next = { href: directChildren[0], label: pageLabelByHref.get(directChildren[0]) || directChildren[0] };
} else if (currentParent) {
  // Normale Seite: Vor/Zurück innerhalb der gleichen Ebene (gleicher Parent)
  const siblings = allHrefs
    .filter((h) => parentOf(h) === currentParent && depthOf(h) === currentDepth)
    .sort(byOrder);

  const idx = siblings.findIndex((h) => norm(h) === currentPath);
  const prevHref = idx > 0 ? siblings[idx - 1] : null;
  const nextHref = idx >= 0 && idx < siblings.length - 1 ? siblings[idx + 1] : null;

  prev = prevHref ? { href: prevHref, label: pageLabelByHref.get(prevHref) || prevHref } : null;
  next = nextHref ? { href: nextHref, label: pageLabelByHref.get(nextHref) || nextHref } : null;
}

const canonicalUrl = canonical
  ? canonical
  : (Astro.site
      ? new URL(Astro.url.pathname, Astro.site).toString()
      : new URL(Astro.url.pathname, site.baseUrl).toString());
const canonicalUrlNorm = canonicalUrl.endsWith('/') ? canonicalUrl : `${canonicalUrl}/`;

// Share cards: docs behave like articles.
const ogTypeFinal = isDone ? 'article' : 'website';

// JSON-LD (lightweight): Breadcrumbs + Page/Article schema
// Note: UI breadcrumbs already contain microdata; JSON-LD helps some tools and parsers.
const crumbs = makeBreadcrumbs({
  pathname: Astro.url?.pathname || '/',
  title,
  nav,
  homeLabel: 'Start',
  homeHref: '/start/',
});

const baseJsonLd = isDone ? [
  breadcrumbJsonLd(crumbs),
  pageJsonLd({
    schemaType,
    title,
    description,
    url: (url || Astro.url?.pathname || '/'),
    updated,
    ogImage,
    // If this is a directory/collection page and we also emit an ItemList,
    // link it as mainEntity for stronger semantic clarity.
    ...(schemaType === 'CollectionPage' && structuredDataExtra
      ? (() => {
          const extra = Array.isArray(structuredDataExtra) ? structuredDataExtra : [structuredDataExtra];
          const item = extra.find((x) => x && (x['@type'] === 'ItemList') && (x['@id'] || x.url));
          const mainEntityId = item ? (item['@id'] || item.url) : null;
          // about: allow explicit topic label, otherwise fall back to chapter for directories.
          const about = fm.schemaAbout ? String(fm.schemaAbout) : ((fm.format === 'directory' && chapter) ? String(chapter) : undefined);
          return mainEntityId ? { mainEntityId, about } : (about ? { about } : {});
        })()
      : {}),
  }),
] : null;

const structuredData = isDone
  ? (
      structuredDataExtra
        ? [...baseJsonLd, ...(Array.isArray(structuredDataExtra) ? structuredDataExtra : [structuredDataExtra])]
        : baseJsonLd
    )
  : null;
---
<Base
  title={title}
  description={description}
  robots={robotsFinal}
  ogType={ogTypeFinal}
  ogImage={ogImage}
  updated={updated}
  canonical={canonical}
  structuredData={structuredData}
>
  <!-- Base.astro already provides the single <main>. Keep the document structure valid. -->
  <div class={"container content" + (isAnbieter ? " is-anbieter" : "")}>
    <header class="page-hero">
      <Breadcrumbs title={title} />
      <h1 class="page-title">{title}</h1>
      {heroSub ? <p class="page-sub">{heroSub}</p> : null}
      <div class="page-meta">
        <span>{readingLabel}</span>
        {updated ? (<><span class="dot">•</span><span>Zuletzt aktualisiert: {updated}</span></>) : null}
        {chapter ? (<><span class="dot">•</span><span>{chapter}</span></>) : null}
        {(level && String(level).toLowerCase() !== 'none') ? (<><span class="dot">•</span><span>{level}</span></>) : null}
        {tested_with ? (<><span class="dot">•</span><span>Getestet mit: {tested_with}</span></>) : null}
      </div>

      {/* Anbieter-Fakten werden unterhalb als erstes Element im Layout gerendert,
          damit die Box exakt mit TOC + Article-Body ausgerichtet ist. */}

      {changelog ? (
        <details class="meta-changelog">
          <summary>Änderungen</summary>
          {Array.isArray(changelog) ? (
            <ul class="list">{changelog.map((x) => (<li>{x}</li>))}</ul>
          ) : (
            <p class="muted">{changelog}</p>
          )}
        </details>
      ) : null}

      {(ctaPrimary || ctaSecondary) ? (
        <div class="hero-actions" aria-label="Schnellstart">
          {ctaPrimary && ctaPrimary.href ? (
            <a class="btn primary" href={ctaPrimary.href}>{ctaPrimary.label ?? 'Plan erstellen'}</a>
          ) : null}
          {ctaSecondary && ctaSecondary.href ? (
            <a class="btn" href={ctaSecondary.href}>{ctaSecondary.label ?? 'Mehr'}</a>
          ) : null}
        </div>
      ) : null}
    </header>

    <div class={"layout" + (!showToc ? " layout-single" : "")}>
      {isAnbieter && isDone && provider ? (
        <section class="anbieter-facts" aria-label="Anbieter-Fakten">
          {(providerBadges && providerBadges.length) ? (
            <div class="provider-badges" aria-label="Eigenschaften">
              {providerBadges.map((b) => (
                <span class={"badge" + (b.tone ? " badge-" + b.tone : "")}>{b.label}</span>
              ))}
            </div>
          ) : null}

          {(providerTiles && providerTiles.length) ? (
            <div class="anbieter-tiles" aria-label="Kurzüberblick">
              {providerTiles.map((t) => (
                <div class="anbieter-tile">
                  <div class="k">{t.k}</div>
                  <div class="v">{t.v}</div>
                </div>
              ))}
            </div>
          ) : null}

          <p class="muted anbieter-go-hint">
            <em>Nur Affiliate-Links</em> laufen über <code>/go/&lt;slug&gt;</code>, um Klicks <em>anonym und aggregiert</em> zu zählen (keine Cookies, keine IDs). Nicht‑Affiliate‑Links sind direkte Klarlinks. Details: <a href="/affiliate-hinweis/">Affiliate-Hinweis</a>.</p>

          {(providerLinks && providerLinks.length) ? (
            <div class="anbieter-links" aria-label="Anbieter-Links">
              {providerLinks.map((l) => (
                <a class="btn anbieter-link" href={l.href} target="_blank" rel="noopener noreferrer">{l.label}</a>
              ))}
            </div>
          ) : null}
        </section>
      ) : null}
      {showToc ? <TOC headings={headings} /> : null}

      <article class="article" itemscope itemtype={schemaType} itemid={pageUrl}>
        <meta itemprop="headline" content={title} />
        <meta itemprop="description" content={description} />
        {updated ? <meta itemprop="dateModified" content={updated} /> : null}

        {hasPfade ? (
          <>
            <noscript>
              <div class="callout noscript-note">
                <p><strong>JavaScript ist deaktiviert.</strong> Der Pfad‑Schalter (A/B/C) funktioniert ohne JavaScript nicht.</p>
                <p>Du kannst trotzdem alles lesen: öffne die Abschnitte <em>„Pfad B“</em> / <em>„Pfad C“</em> einfach manuell über die Aufklappfelder im Text.</p>
              </div>
            </noscript>

            <div class="pfad-sticky" data-pfad-sticky>
              <div class="pfad-bar" data-pfad-toggle aria-label="Pfad auswählen">
                <div class="pfad-left">
                  <span class="pfad-label" aria-hidden="true">Pfad</span>
                  <div class="pfad-seg" role="radiogroup" aria-label="Wie weit willst du gehen?">
                    <label class="pfad-opt" title="Pfad A: Standard (Alltag)">
                      <input type="radio" name="pfad" value="A" />
                      <span>A</span>
                    </label>
                    <label class="pfad-opt" title="Pfad B: Datensparsam">
                      <input type="radio" name="pfad" value="B" />
                      <span>B</span>
                    </label>
                    <label class="pfad-opt" title="Pfad C: High-Risk">
                      <input type="radio" name="pfad" value="C" />
                      <span>C</span>
                    </label>
                  </div>
                </div>
                <div class="pfad-hint" aria-hidden="true">
                  <span><strong>A</strong> Alltag</span>
                  <span class="dot">•</span>
                  <span><strong>B</strong> datensparsam</span>
                  <span class="dot">•</span>
                  <span><strong>C</strong> High-Risk</span>
                  <span class="dot">•</span>
                  <span class="pfad-note">B/C öffnet Details</span>
                </div>
              </div>
            </div>
          </>
        ) : null}

        {isDone ? (
          <>
            {(quickHref || verifyHref || pitfallsHref) ? (
              <div class="callout in20" aria-label="In 20 Sekunden">
                <div class="in20-title"><strong>In 20 Sekunden</strong></div>
                <p class="in20-desc">Springe direkt zu den relevanten Stellen – ohne die ganze Seite durchzuscrollen.</p>
                <ul class="list">
                  {quickHref ? (<li><a href={quickHref}>Quick Wins</a></li>) : null}
                  {verifyHref ? (<li><a href={verifyHref}>Prüfen</a></li>) : null}
                  {pitfallsHref ? (<li><a href={pitfallsHref}>Stolpersteine / Fehler</a></li>) : null}
                </ul>
              </div>
            ) : null}

            <div class="article-body markdown" set:html={slotHtml} />

            <EeatBox
              updated={updated}
              tested_with={tested_with}
              changelog={changelog}
              isAnbieter={isAnbieter}
              scope={chapter ? `Kapitel: ${chapter}` : null}
            />
          </>
        ) : (
          <div class="article-body markdown">
            <div class="callout">
              <p><strong>Hinweis:</strong> Diese Seite ist derzeit <strong>{status === 'archived' ? 'archiviert' : 'in Arbeit'}</strong> und wird bewusst nicht indexiert.</p>
              <p>
                Nutze solange das <a href="/anbieter/">Anbieter-Verzeichnis</a> oder die Suche oben.
              </p>
            </div>
          </div>
        )}

        {(prev || next) ? (
          <nav class={"prevnext" + ((!prev || !next) ? " single" : "")} aria-label="Weiter / Zurück">
            {prev ? (
              <a class="prev" href={prev.href}>
                <div class="k">Zurück</div>
                <div class="t">{prev.label}</div>
              </a>
            ) : null}
            {next ? (
              <a class="next" href={next.href}>
                <div class="k">Weiter</div>
                <div class="t">{next.label}</div>
              </a>
            ) : null}
          </nav>
	        ) : null}

              


      </article>
    </div>
  </div>
  {isAnbieter ? (
    <script src={kvCardsUrl} defer></script>
  ) : null}


</Base>
